#!/usr/bin/env python
# coding: utf-8

# In[ ]:


get_ipython().run_cell_magic('writefile', 'model2.py', '\nimport streamlit as st\nimport pandas as pd \nimport tensorflow as tf\nfrom tensorflow.keras.preprocessing.sequence import pad_sequences\nfrom tensorflow.keras.preprocessing.text import Tokenizer\nimport time\n\n\npage_element="""<style>\n[data-testid="stAppViewContainer"]{\n  background-image: url("https://wallup.net/wp-content/uploads/2019/09/859126-poster-movie-film-movies-posters.jpg");\n  background-size:cover;\n  \n}\n</style>\n"""\n\nst.markdown(page_element, unsafe_allow_html=True)\nimport pandas as pd \nimport tensorflow as tf\nfrom tensorflow.keras.preprocessing.sequence import pad_sequences\nfrom tensorflow.keras.preprocessing.text import Tokenizer\n\n# Load the IMDb dataset\nimdb_df = pd.read_csv(\'imdb_movie_reviews.csv\')\n\n# Load the trained model\nmodel = tf.keras.models.load_model(\'movie_review_sentiment_analysis.keras\')\n\n# Load the Tokenizer\ntokenizer = Tokenizer(num_words=5000, oov_token=\'<OOV>\')\ntokenizer.fit_on_texts(imdb_df[\'review\'])\n\n# Define mapping for sentiment labels\nsentiment_map = {1: "Positive review", 0: "Negative review"}\n\n# Function to preprocess text\ndef preprocess_text(text):\n    sequence = tokenizer.texts_to_sequences([text])\n    padded_sequence = pad_sequences(sequence, maxlen=256)\n    return padded_sequence\n\n# Function to predict sentiment label\ndef predict_sentiment_label(text):\n    start_time = time.time()\n    processed_text = preprocess_text(text)\n    prediction = model.predict(processed_text)[0][0]\n    sentiment_label = sentiment_map[int(round(prediction))]\n    end_time = time.time()\n    runtime = end_time - start_time\n    \n    # Convert sentiment label to numerical value\n    sentiment_value = 1 if sentiment_label == \'Positive review\' else 0\n    \n    # Calculate loss\n    true_label = imdb_df[\'sentiment\'][0]\n    true_value = 1 if true_label == \'positive\' else 0\n    loss = abs(prediction - true_value)\n    \n#      # Calculate loss\n#     loss = abs(prediction - imdb_df[\'sentiment\'][0])\n    \n    return sentiment_label, runtime, loss\n\n#     processed_text = preprocess_text(text)\n#     prediction = model.predict(processed_text)[0][0]\n#     sentiment_label = sentiment_map[int(round(prediction))]\n#     return sentiment_label\n\ndef calculate_accuracy():\n    correct_predictions = 0\n    total_predictions = len(imdb_df)\n    \n    for index, row in imdb_df.iterrows():\n        text = row[\'review\']\n        true_label = row[\'sentiment\']\n        predicted_label, _, _ = predict_sentiment_label(text)\n        if true_label == predicted_label:\n            correct_predictions += 1\n    \n    accuracy = correct_predictions / total_predictions\n    return accuracy\n\n\n# Define the Streamlit app\ndef main():\n    st.title("IMDb Movie Review Sentiment Analysis")\n    review_text = st.text_area("Enter your movie review here:")\n    # selected_review = st.selectbox("Select a Review", imdb_df[\'review\'])\n\n    # Button to predict sentiment\n    if st.button("Predict"):\n        if review_text.strip() == "":\n            st.error("Please select a movie review.")\n        else:\n            # Predict sentiment label\n            sentiment_label,runtime,loss = predict_sentiment_label(review_text)\n            st.success(f"Sentiment: **{sentiment_label}**")\n            st.success(f"Runtime: {runtime:.4f} seconds")\n            st.error(f"Loss: {loss:.4f}")\n            \n            # Calculate and display accuracy\n            accuracy = calculate_accuracy()\n            st.success(f"Accuracy: {accuracy:.4f}")\n            \n#             if sentiment_label == "Positive review":\n#                 st.success("Sentiment: **Positive review**")\n#             else:\n#                 st.error("Sentiment: **Negative review**")\n    \n\nif __name__ == "__main__":\n    main()\n')

